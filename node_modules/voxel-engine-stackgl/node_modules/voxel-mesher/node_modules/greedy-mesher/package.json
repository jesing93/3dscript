{
  "name": "greedy-mesher",
  "version": "1.0.3",
  "description": "Greedy mesh compiler",
  "main": "greedy.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "iota-array": "^1.0.0",
    "typedarray-pool": "^1.1.0",
    "uniq": "^1.0.1"
  },
  "devDependencies": {
    "ndarray": "~1.0.5",
    "ndarray-pack": "~1.0.1",
    "tape": "~1.0.4",
    "compare": "~0.0.1",
    "aabb-2d": "~0.0.0",
    "aabb-3d": "~0.0.0",
    "ndarray-fill": "~0.1.0",
    "zeros": "~0.0.0"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/greedy-mesher.git"
  },
  "keywords": [
    "greedy",
    "mesh",
    "compiler",
    "voxel",
    "geometry",
    "ndarray"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "154f0e316690fccce1148d4622c9274bbeec4401",
  "bugs": {
    "url": "https://github.com/mikolalysenko/greedy-mesher/issues"
  },
  "readme": "greedy-mesher\n=============\nA flexible system for generating [greedy meshes](http://0fps.wordpress.com/2012/07/07/meshing-minecraft-part-2/) of [ndarrays](https://github.com/mikolalysenko/ndarray).\n\n## Example\n\n```javascript\nvar compileMesher = require(\"greedy-mesher\")\n\nvar mesher = compileMesher({\n  extraArgs: 1,\n  order: [1, 0],\n  append: function(lo_x, lo_y, hi_x, hi_y, val, result) {\n    result.push([[lo_x, lo_y], [hi_x, hi_y]])\n  }\n})\n\nvar test_array = require(\"ndarray-pack\")(\n[[0, 2, 0, 0],\n [0, 1, 1, 0],\n [0, 1, 1, 0],\n [0, 0, 0, 0]])\n\nvar result = []\nmesher(test_array, result)\nconsole.log(result); \n// outputs: [ [ [ 1, 0 ], [ 2, 1 ] ], [ [ 1, 1 ], [ 3, 3 ] ] ]\n```\n\n## Install\n\n    npm install greedy-mesher\n    \n### `require(\"greedy-mesher\")(options)`\nThis routine generates a greedy mesher for a given order and list of closures\n\n* `order` An array representing the order in which to mesh the input.\n* `extraArgs` The number of optional arguments to pass to each closure.\n* `skip(a,...)` A closure which tests if the given voxel should be skipped.  (Default: skips 0)\n* `merge(a,b,...)` A closure which tests if voxels a and b can be merged in the mesh.  (Default: checks if voxels are equal)\n* `append(lo0, lo1, ..., lon, hi0, hi1, ..., hin, val, ...)`\n* `useGetter` if set, use `.get()` to access underlying data store\n* `debug` If set, print out the generated source code to the console\n\n**Returns** A compiled mesh generator.  Call this method using:\n\n```javascript\nvar my_mesh = mesher(array, option1, option2, ...)\n```\n\n## Credits\n(c) 2013 Mikola Lysenko. MIT License\n\n",
  "_id": "greedy-mesher@1.0.3",
  "_from": "greedy-mesher@^1.0.2"
}
